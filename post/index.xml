<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Baykier的鱼塘</title>
    <link>http://i90.xyz/post/index.xml</link>
    <description>Recent content in Posts on Baykier的鱼塘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Written by Baykier</copyright>
    <lastBuildDate>Thu, 19 Apr 2018 10:00:36 +0800</lastBuildDate>
    <atom:link href="http://i90.xyz/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>mongodb如何在aggregate中进行distinct操作 </title>
      <link>http://i90.xyz/post/mongo-aggregate/</link>
      <pubDate>Thu, 19 Apr 2018 10:00:36 +0800</pubDate>
      
      <guid>http://i90.xyz/post/mongo-aggregate/</guid>
      <description>

&lt;h2 id=&#34;mongodb如何在aggregate中进行distinct操作&#34;&gt;mongodb如何在aggregate中进行distinct操作&lt;/h2&gt;

&lt;p&gt;mongodb 在聚合操作中，经常需要同传统的sql一样，进行诸如 sum(distinct) ,group by having 操作，那么等价的mongodb是啥呢？&lt;/p&gt;

&lt;h3 id=&#34;场景描述&#34;&gt;场景描述&lt;/h3&gt;

&lt;p&gt;现在需要用mongodb来记录业务员的外呼记录，使用三个表，结构分别如下：(实际情况可能有出入，抽出主要的字段说明)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;业务员 admin_user&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义及说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;业务员id&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;姓名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;客户表 user&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义及说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;uid&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;客户id&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;姓名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;关联表 call_log&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义及说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;auid&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;业务员id&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;uid&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;客户id&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ctime&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;呼叫时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;那么问题来了-如何找出具体某一天的业务员呼叫的客户数量&#34;&gt;那么问题来了，如何找出具体某一天的业务员呼叫的客户数量？&lt;/h3&gt;

&lt;p&gt;这时候，如果简单的用mysql来处理，简单的一条sql就行了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT auid,COUNT(DISTINCT uid) AS call_count FROM call_log WHERE ctime &amp;gt;=&amp;lt;时间戳&amp;gt; AND ctime &amp;lt;= &amp;lt;时间戳&amp;gt; GROUP BY auid

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是用mongodb来处理，我找了半天，也没发现有distinct对等的函数，从stackoverflow上找到了答案，思路就是分两次组，第一次按auid，uid，第二次按auid，这样就会去重（一天可以呼叫同一个业务员多次)&lt;/p&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
db.campaigns.aggregate([
    { &amp;quot;$match&amp;quot;: { &amp;quot;ctime&amp;quot;: { &amp;quot;$gte&amp;quot;: &amp;lt;时间戳&amp;gt;，&amp;quot;$lte&amp;quot;:&amp;lt;时间戳&amp;gt; }}},
    { &amp;quot;$group&amp;quot;: {
        &amp;quot;_id&amp;quot;: {
            &amp;quot;auid&amp;quot;: &amp;quot;$auid&amp;quot;,
            &amp;quot;uid&amp;quot;: &amp;quot;$uid&amp;quot;
        },
        &amp;quot;count&amp;quot;: { &amp;quot;$sum&amp;quot;: 1 }
    }},
    { &amp;quot;$group&amp;quot;: {
        &amp;quot;_id&amp;quot;: &#39;$_id.auid&#39;,
        &amp;quot;count&amp;quot;: { &amp;quot;$sum&amp;quot;: 1 }
    }}
])


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参考链接&#34;&gt;　参考链接&lt;/h3&gt;

&lt;p&gt;－　&lt;a href=&#34;https://stackoverflow.com/questions/24761266/select-group-by-count-and-distinct-count-in-same-mongodb-query?utm_medium=organic&amp;amp;utm_source=google_rich_qa&amp;amp;utm_campaign=google_rich_qa&#34;&gt;mongodb group distinct&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>extreme injector 进程注入工具使用</title>
      <link>http://i90.xyz/post/extreme_injector_use/</link>
      <pubDate>Wed, 21 Mar 2018 10:00:36 +0800</pubDate>
      
      <guid>http://i90.xyz/post/extreme_injector_use/</guid>
      <description>

&lt;h2 id=&#34;extreme-injector-进程注入工具使用&#34;&gt;extreme injector 进程注入工具使用&lt;/h2&gt;

&lt;p&gt;windows dll 注入是大部分游戏辅助的实现方式，这次来介绍使用最广泛的extreme injector&lt;/p&gt;

&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;extreme injector 是一个非常强大和高级的dll注入工具，配有一个简单的GUI界面，使用c#编写
&lt;img src=&#34;../images/extreme_injector/01.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;../images/extreme_injector/02.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;../images/extreme_injector/03.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;它具有以下特性:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多种外观和允许自定义GUI&lt;/li&gt;
&lt;li&gt;进程列表选择或者桌面程序选择&lt;/li&gt;
&lt;li&gt;多dll注入支持（并支持enable/disable选择）&lt;/li&gt;
&lt;li&gt;自动开启注入&lt;/li&gt;
&lt;li&gt;隐藏注入行为&lt;/li&gt;
&lt;li&gt;dll抢占式注入&lt;/li&gt;
&lt;li&gt;取消dll注入&lt;/li&gt;
&lt;li&gt;多种注入方法（Standard, LdrLoadDll Stub, LdrpLoadDll Stub, Thread Hijacking and Manual Map）&lt;/li&gt;
&lt;li&gt;支持拖拽操作&lt;/li&gt;
&lt;li&gt;支持x64平台&lt;/li&gt;
&lt;li&gt;Visual C++依赖库自动安装&lt;/li&gt;
&lt;li&gt;注册后导出导出的功能函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;如何使用&#34;&gt;如何使用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;下载并解压文件(&lt;a href=&#34;https://github.com/master131/ExtremeInjector&#34;&gt;github下载地址&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;运行&lt;strong&gt;Injector v3.exe&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;点击设置(setting)来开启选项 Start in Secure Mode 来避免被反欺诈引擎识别&lt;/li&gt;
&lt;li&gt;点击select按钮来选择要注入的进程,可以选择正在运行的进程或者桌面中可执行文件的名字(以exe扩展)&lt;/li&gt;
&lt;li&gt;点击inject完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;相关链接&#34;&gt;相关链接&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/master131/ExtremeInjector/wiki&#34;&gt;github wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.unknowncheats.me/forum/general-programming-and-reversing/213038-extreme-injector-v3-7-a.html&#34;&gt;原文链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>WebAssembly的发展与对web的影响</title>
      <link>http://i90.xyz/post/webassembly-with-web/</link>
      <pubDate>Fri, 02 Mar 2018 10:00:36 +0800</pubDate>
      
      <guid>http://i90.xyz/post/webassembly-with-web/</guid>
      <description>

&lt;h2 id=&#34;webassembly的发展与对web的影响&#34;&gt;WebAssembly的发展与对web的影响&lt;/h2&gt;

&lt;p&gt;WebAssembly或称wasm是一个实验性的低级编程语言，应用于浏览器内的客户端。WebAssembly是便携式的抽象语法树，被设计来提供比JavaScript更快速的编译及运行[2]。WebAssembly将让开发者能运用自己熟悉的编程语言（最初以C/C++作为实现目标）编译，再藉虚拟机引擎在浏览器内运行。WebAssembly的开发团队分别来自Mozilla、Google、Microsoft、Apple，代表着四大网络浏览器Firefox、Chrome、Microsoft Edge、Safari。2017年11月，所有以上四个浏览器都开始实验性的支持WebAssembly&lt;/p&gt;

&lt;p&gt;简而言之，WebAssembly可以为C和C++编写的源码提供一个编译格式，使其能够运行在浏览器端，并暴露给JavaScript调用，这样一来，对于前端来说，将会引起巨大的变革,比如游戏,视频等等
具体请参考官方文档的介绍&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/WebAssembly/Concepts#WebAssembly%E7%9A%84%E7%9B%AE%E6%A0%87&#34;&gt;WebAssembly的目标&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;webassembly-目前浏览器支持&#34;&gt;WebAssembly 目前浏览器支持&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;浏览器&lt;/th&gt;
&lt;th&gt;是否支持WebAssembly&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Chrome&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Firfox&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Edge&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Oprea&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Android&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ios&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;safari&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;QQ浏览器&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Uc浏览器&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;据目前情况看，几乎所有的主流浏览器都已经支持WebAssembly，无论是PC上的Chrome,Firefox,Ie还是移动端的Uc,QQ浏览器(微信内核来自QQ浏览器内核，也支持),所以说WebAssembly的发展未来前途无量!&lt;/p&gt;

&lt;p&gt;具体参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/WebAssembly&#34;&gt;WebAssembly浏览器支持&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://x5.tencent.com/tbs/history.html#/detail/17&#34;&gt;X5内核升级支持WebAssembly&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/28546930&#34;&gt;U4 内核 WebGL 支持发展方向&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;webassembly-编程语言支持&#34;&gt;WebAssembly 编程语言支持&lt;/h3&gt;

&lt;p&gt;目前完美支持WebAssembly的编程语言如下，相信未来会有更多的语言支持&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rust&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lua&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体参考&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/appcypher/awesome-wasm-langs&#34;&gt;WebAssembly语言支持&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;对web的影响&#34;&gt;对Web的影响&lt;/h3&gt;

&lt;p&gt;目前最主要的编程方式的改变，未来C/C++肯定会在Web前端大放光彩,比如加密解密，视频压缩，裁剪等等，Web平台相应的应用范围得益于WebAssembly也会越来越广，在游戏领域会有更大的作为.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编程语言C/C++肯定爆发一波&lt;/li&gt;
&lt;li&gt;前端开发会越来越重要，原生应用的开发者会面临很大的冲击&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;相关参考&#34;&gt;相关参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mbasso/awesome-wasm#languages&#34;&gt;awesome-WebAssembly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://webassembly.org/&#34;&gt;http://webassembly.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>vagrant windows 大小写问题解决</title>
      <link>http://i90.xyz/post/vagrant-win-case-sensetive/</link>
      <pubDate>Thu, 01 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://i90.xyz/post/vagrant-win-case-sensetive/</guid>
      <description>

&lt;h2 id=&#34;vagrant-windows-大小写问题解决&#34;&gt;vagrant windows 大小写问题解决&lt;/h2&gt;

&lt;p&gt;开发环境使用vagrant，以为这样能很好的解决开发中的坑，没想到还是中了不区分大小写的问题的坑，记录下来，防止踩坑&lt;/p&gt;

&lt;p&gt;开发环境: host windwos 10
虚拟机: guest debian8
出现的问题： 工作中使用php开发的cli脚本，需要到线上服务器执行，本地写完了，执行后返回预期的结果，开开心心的到服务器一运行，发现居然没反应(ps 和框架的异常机制也有问题)，
找了半天才发现是文件大小写的问题，由于使用vagrant在linux环境开发，就没有意识到这一点（默哀三秒。。。）然后查找相关资料，才发现使用virtualbox 默认挂载的目录是不区文件分大小写的
在guest中同样也是不区分，最开始的解决思路就是看看php能不能解决这个问题（让php跨平台的支持文件大小写）后来发现php底层是依赖与操作系统的，php本身无法解决，于是重点来了：
如何让windows+virtualbox中的vagrant支持区分文件大小写&lt;/p&gt;

&lt;h3 id=&#34;vagrant在windows-virtualbox-支持文件区分大小写&#34;&gt;vagrant在windows+virtualbox 支持文件区分大小写&lt;/h3&gt;

&lt;p&gt;要想让vagrant 在windows host中支持文件大小写，需求通过安装插件来支持:nfs&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开cmd命令行或者git bash:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;vagrant plugin install vagrant-winnfsd

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等执行完成后进行下一步&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在Vagrantfile添加 挂载参数 type:&amp;ldquo;nfs&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;config.vm.synced_folder &amp;quot;./project&amp;quot;, &amp;quot;/project&amp;quot;, type:&amp;quot;nfs&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;添加private_network支持(插件依赖 &lt;a href=&#34;https://github.com/winnfsd/vagrant-winnfsd#activate-nfs-for-vagrant):&#34;&gt;https://github.com/winnfsd/vagrant-winnfsd#activate-nfs-for-vagrant):&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;config.vm.network &amp;quot;private_network&amp;quot;, type: &amp;quot;dhcp&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;vagrant reload虚拟机&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;vagrant reload

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ok-到这一步-问题算是解决了-让我们愉快的玩耍吧&#34;&gt;ok！ 到这一步，问题算是解决了，让我们愉快的玩耍吧 :)&lt;/h3&gt;

&lt;h3 id=&#34;相关链接&#34;&gt;相关链接&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/winnfsd/vagrant-winnfsd#activate-nfs-for-vagrant&#34;&gt;https://github.com/winnfsd/vagrant-winnfsd#activate-nfs-for-vagrant&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/26483867/how-to-handle-files-in-case-sensitive-way-in-vagrant-on-windows-host&#34;&gt;https://stackoverflow.com/questions/26483867/how-to-handle-files-in-case-sensitive-way-in-vagrant-on-windows-host&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript跨域访问控制问题</title>
      <link>http://i90.xyz/post/js_cors/</link>
      <pubDate>Mon, 11 Sep 2017 08:50:38 +0000</pubDate>
      
      <guid>http://i90.xyz/post/js_cors/</guid>
      <description>

&lt;h2 id=&#34;javascript跨域访问控制问题&#34;&gt;JavaScript跨域访问控制问题&lt;/h2&gt;

&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;情景一&lt;/strong&gt;由于公司的文件上传采用单独的文件服务器管理，把上传文件操作做了统一抽象，形成了一个API接口，不管是前端（包括APP），
后端，采用文件上传时，均采用一个接口，重要的是文件上传API地址是单独的一台服务器。对于后端和APP端来说，还好
，但是对于前端（H5）来说，就存在跨域的请求问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;情景二&lt;/strong&gt;作为前端开发(H5),本地搭建测试环境，例如&lt;code&gt;http://localhost&lt;/code&gt;，链接测试环境的接口&lt;code&gt;http://test.xxxxx.com&lt;/code&gt;,这时候，由于
请求的也不是同一个服务器，也会存在跨域问题&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;什么是跨域访问&#34;&gt;什么是跨域访问&lt;/h3&gt;

&lt;p&gt;当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个&lt;strong&gt;跨域 HTTP 请求&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;如何解决跨域请求问题&#34;&gt;如何解决跨域请求问题&lt;/h3&gt;

&lt;p&gt;要解决跨域问题，有两种方式:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;配置服务器，添加允许的跨域访问域名，从而使浏览器正常接收ajax返回的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;server {
		listen       80;
		server_name  test.com;
		location /{
			add_header &#39;Access-Control-Allow-Origin&#39; &#39;http://a.com&#39;;
			add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;
			add_header &#39;Access-Control-Allow-Methods&#39; &#39;POST&#39;;
		}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;如果后端使用php，则可以在index.php入口文件简单修改:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;// 指定允许其他域名访问
header(&#39;Access-Control-Allow-Origin:http:localhost&#39;);
header(&#39;Access-Control-Allow-Credentials:true&#39;);
// 响应类型
header(&#39;Access-Control-Allow-Methods:POST&#39;);
// 响应头设置
header(&#39;Access-Control-Allow-Headers:x-requested-with,content-type&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;相关阅读&#34;&gt;相关阅读&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS&#34;&gt;HTTP跨域访问控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.w2fzu.com/2016/11/21/2016-11-21-PHP-CORS/&#34;&gt;PHP 解决 CORS 跨域问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>php扩展模块加载顺序</title>
      <link>http://i90.xyz/post/php_ext_load_order/</link>
      <pubDate>Wed, 30 Aug 2017 10:31:22 +0000</pubDate>
      
      <guid>http://i90.xyz/post/php_ext_load_order/</guid>
      <description>

&lt;h2 id=&#34;php扩展模块的加载顺序&#34;&gt;php扩展模块的加载顺序&lt;/h2&gt;

&lt;h3 id=&#34;为啥会有这个问题&#34;&gt;为啥会有这个问题？&lt;/h3&gt;

&lt;p&gt;今天在安装php的扩展&lt;a href=&#34;http://pecl.php.net/package/APM&#34;&gt;apm&lt;/a&gt;的时候，文档写着必须在json扩展加载之后再加载apm模块,原文如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Activate the extension in the php configuration by adding:

extension=apm.so
Note: APM depends on JSON, so the apm.so extension must be loaded after JSON!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;那么php的扩展加载顺序是怎么的&#34;&gt;那么php的扩展加载顺序是怎么的?&lt;/h3&gt;

&lt;p&gt;按照php手册上面的说明，php扩展加载是写在php.ini文件中配置的，而php的配置文件是顺序解析的，这说明除了默认内核扩展，php的其他扩展模块
的加载顺序就是php.ini中的先后顺序，这是针对php.ini中的配置。对于ubuntu来说，php的扩展配置是单独放置在额外的配置目录，每一个扩展加载都是
一个配置文件，类似&lt;a href=&#34;http://nginx.org/&#34;&gt;nginx&lt;/a&gt;的站点配置，以ubuntu-16.04-LTS为例：&lt;/p&gt;

&lt;p&gt;如果我们要安装php的curl扩展:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt update &amp;amp;&amp;amp; sudo apt install php7.0-curl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终会在php的扩展目录安装curl.so（/usr/lib/php/20151012/）,同时会在php的mods_available目录新增配置文件(curl.ini),这时候，php的
curl扩展还没有加载，需要将&lt;code&gt;curl.ini&lt;/code&gt;软连接到&lt;code&gt;/etc/php/7.0/fpm/conf.d/&lt;/code&gt;，重启php的fpm才会生效&lt;/p&gt;

&lt;h4 id=&#34;php扩展配置目录&#34;&gt;php扩展配置目录&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../images/ubuntu_php_7.0_mods_available.png&#34; alt=&#34;php扩展配置目录&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;php的fpm扩展加载目录&#34;&gt;php的fpm扩展加载目录&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;../images/ubuntu_php_7.0_fpm_conf.d.png&#34; alt=&#34;php的fpm扩展加载目录&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么问题来了，如果以这种方式加载php的扩展，扩展的加载顺序如何呢？&lt;/p&gt;

&lt;p&gt;答案就是安装配置文件目录的&lt;code&gt;文件自然排序&lt;/code&gt;顺序加载的.至于为什么，看了php的扩展加载目录前面的那个数字就明白了。&lt;/p&gt;

&lt;h3 id=&#34;相关阅读&#34;&gt;相关阅读&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.laruence.com/2009/08/18/1042.html&#34;&gt;保证PHP扩展的依赖关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://php.net/manual/zh/install.php&#34;&gt;php的安装与配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>nginx ssl 证书配置</title>
      <link>http://i90.xyz/post/nginx_ssl/</link>
      <pubDate>Tue, 29 Aug 2017 05:23:25 +0000</pubDate>
      
      <guid>http://i90.xyz/post/nginx_ssl/</guid>
      <description>

&lt;h2 id=&#34;nginx-ssl证书配置&#34;&gt;nginx ssl证书配置&lt;/h2&gt;

&lt;p&gt;一般在开发环境中，ssl时没有必要设置的，但是因为测试需要用到https环境，所以就记录下来，当学习了。&lt;/p&gt;

&lt;h3 id=&#34;生成ssl证书&#34;&gt;生成ssl证书&lt;/h3&gt;

&lt;p&gt;https 需要证书，所需要的证书一般可以自己生成，这时候需要手动添加到浏览器，还有就是去证书网站申请,推荐使用
&lt;a href=&#34;https://letsencrypt.org/&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt; (注:这种证书只能使用3个月的时间，过期需要再次申请)
我们这里仅需要自己手动生成证书就可以了&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成密钥key,执行下面的命令，输入两次密码就可以了&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;openssl genrsa -des3 -out dev.key 1024
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;利用密钥key生成证书crt文件,执行下面的命令，输入证书的参数就可以了&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;openssl req -new -x509 -key dev.key -out dev.crt -days 3650
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;证书的参数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Country Name 国家名字 (CN 即可)&lt;/li&gt;
&lt;li&gt;State or Province Name 省或地区(BeiJing)&lt;/li&gt;
&lt;li&gt;Locality Name 当地地区 (BeiJing)&lt;/li&gt;
&lt;li&gt;Organization Name 机构名称 (develop Ltd)&lt;/li&gt;
&lt;li&gt;Organizational Unit Name 组织机构单位 (develop)&lt;/li&gt;
&lt;li&gt;Common Name 站点host (dev.com)&lt;/li&gt;
&lt;li&gt;Email Address 邮箱&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;生成不需要密码的密钥,给nginx配置&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;openssl rsa -in dev.key -out dev.nopass.key
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;配置nginx&#34;&gt;配置nginx&lt;/h3&gt;

&lt;p&gt;nginx 配置很简单，导入证书路径即可,下面是一个实例配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
    listen 443;
    server_name dev.cn;

    ssl on;
    ssl_certificate /var/project/conf/nginx/dev.crt;
    ssl_certificate_key /var/project/conf/nginx/dev.nopass.key;

    root /var/project/htdocs/dev/public;

  	# Add index.php to the list if you are using PHP
  	index index.php index.html index.htm index.nginx-debian.html;

  	server_name dev.borrow.cn;

  	location / {
  		# First attempt to serve request as file, then
  		# as directory, then fall back to displaying a 404.
  		try_files $uri /index.php$is_args?$args ;
  	}

  	# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
  	#
  	location ~ \.php {
  		include snippets/fastcgi-php.conf;

  	#	# With php7.0-cgi alone:
  	#	fastcgi_pass 127.0.0.1:9000;
  		# With php7.0-fpm:
  		fastcgi_pass unix:/run/php/php7.0-fpm.sock;
  	}

  	# deny access to .htaccess files, if Apache&#39;s document root
  	# concurs with nginx&#39;s one
  	#
  	#location ~ /\.ht {
  	#	deny all;
  	#}
  	access_log /var/project/log/nginx/dev.cn-access.log;
  	error_log /var/project/log/nginx/dev.cn-error.log;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;相关阅读&#34;&gt;相关阅读&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/littlehann/p/3738141.html&#34;&gt;证书介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/yjmyzz/p/openssl-tutorial.html&#34;&gt;openssl、x509、crt、cer、key、csr、ssl、tls 这些都是什么鬼?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>php file_get_contents() 函数代理设置</title>
      <link>http://i90.xyz/post/php_proxy_file_get_contents/</link>
      <pubDate>Wed, 21 Jun 2017 01:42:02 +0000</pubDate>
      
      <guid>http://i90.xyz/post/php_proxy_file_get_contents/</guid>
      <description>

&lt;h2 id=&#34;php-file-get-contents-函数代理设置&#34;&gt;php file_get_contents() 函数代理设置&lt;/h2&gt;

&lt;h3 id=&#34;遇到的问题&#34;&gt;遇到的问题&lt;/h3&gt;

&lt;p&gt;昨天在使用file_get_contents()函数抓取图片内容的时候，出现超时的情况，而且图片无法获取到
据猜测，是网络的问题，有可能被GFW河蟹了，于是登上我的服务器测试一下，发现在服务器可以正常打开。
所以想到了如何给file_get_contents()函数设置代理,记录下来&lt;/p&gt;

&lt;h3 id=&#34;file-get-contents-代理设置&#34;&gt;file_get_contents()代理设置&lt;/h3&gt;

&lt;p&gt;下面摘自file_get_content()的&lt;a href=&#34;http://php.net/manual/en/function.file-get-contents.php&#34;&gt;php官方手册&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string file_get_contents ( string $filename [, bool $use_include_path = false [, resource $context [, int $offset = 0 [, int $maxlen ]]]] )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，第三个参数&lt;strong&gt;context&lt;/strong&gt;就是一个上下文资源参数，可以使用&lt;a href=&#34;http://php.net/manual/en/function.stream-context-create.php&#34;&gt;stream_context_create()&lt;/a&gt;
来创建&lt;/p&gt;

&lt;p&gt;具体代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$context = stream_context_create(array(
	&#39;http&#39; =&amp;gt; array(
		&#39;proxy&#39; =&amp;gt; &#39;[tcp|udp]&amp;lt;proxy ip&amp;gt;:&amp;lt;proxy port&amp;gt;&#39;,
		&#39;request_fulluri&#39; =&amp;gt; true,
	),
));

//下面是简单的测试

$url = &#39;froyo.cc&#39;;
$content = file_get_contents($url,false,$context);
echo $content;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;相关参考&#34;&gt;相关参考&lt;/h3&gt;

&lt;p&gt;使用strea_context_create()函数的库很多，比如&lt;a href=&#34;https://github.com/guzzle/guzzle&#34;&gt;Guzzle&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&#34;http://php.net/manual/zh/book.stream.php&#34;&gt;php stream&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.oschina.net/translate/understanding-streams-in-php&#34;&gt;理解php的流&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>homepage 的自动部署</title>
      <link>http://i90.xyz/post/auto_deploy/</link>
      <pubDate>Mon, 05 Jun 2017 10:00:36 +0800</pubDate>
      
      <guid>http://i90.xyz/post/auto_deploy/</guid>
      <description>

&lt;h1 id=&#34;homepage自动部署&#34;&gt;homepage自动部署&lt;/h1&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;首先交代一下背景，俺的博客是基于hugo的生成静态站点，代码放在github上面 对于&lt;a href=&#34;https://gohugo.io/&#34;&gt;hugo&lt;/a&gt;
和&lt;a href=&#34;https://github.com/&#34;&gt;github&lt;/a&gt;不是很了解的同学可以去了解一下。&lt;/p&gt;

&lt;p&gt;下面是我写博客的大概流程:&lt;/p&gt;

&lt;p&gt;1.在自己的个人电脑上写博客，用hugo生成静态站点测试无误后推送到github&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 新增博客
  hugo new post/&amp;lt;some_title&amp;gt;.md
# 用编辑器编辑并测试
  hugo server -w

# 生成静态站点
  hugo
#推送到github
  git push origin master
  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.在服务器上面拉取更新站点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /path/to/site
git pull origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过上面的分析可以看出，对于服务器端的每次拉取可以写成一个脚本，利用github的hook机制，这样每次写完博客
测试ok直接推送就行了，省去每次登录服务器，再&lt;code&gt;git pull&lt;/code&gt;的操作，这样岂不美哉！&lt;/p&gt;

&lt;h2 id=&#34;自动部署脚本原理&#34;&gt;自动部署脚本原理&lt;/h2&gt;

&lt;p&gt;其实对于这个机智(偷懒)的想法早就有了，直到昨天下午有时间，才完善了一下。网上有很多类似的代码，实现原理
大同小异,都是根据github的hook机制,需要注意的就是安全方面，具体流程如下面:&lt;/p&gt;

&lt;p&gt;1.博客更新推送到github&lt;/p&gt;

&lt;p&gt;2.github推送webhook到url&lt;/p&gt;

&lt;p&gt;3.url里面验证推送的来源(确保安全),执行代码拉取完成更新&lt;/p&gt;

&lt;h2 id=&#34;编写php脚本-因为php是最好的语言么&#34;&gt;编写php脚本(因为php是最好的语言么)&lt;/h2&gt;

&lt;p&gt;代码可以在这里找到&lt;a href=&#34;https://github.com/baykier/homepage/blob/master/froyo.cc/public/index.php&#34;&gt;homepage自动部署脚本&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
/**
 * homepage 自动更新脚本
 */

/**
 * CSV 软件 Git
 */
define(&#39;CSV_SOFT&#39;,&#39;git&#39;);
/**
 * HASH for github.com
 */
define(&#39;HASH&#39;,&#39;59341c1092c47&#39;);
define(&#39;ROOT_PATH&#39;,dirname(dirname(__DIR__)));
define(&#39;LOG_FILE&#39;,ROOT_PATH .&#39;/git-auto-pull.log&#39;);

/**
 * 获取上次命令的状态
 * echo $?
 * @return int
 */
function getShellStatus()
{
    return (int) shell_exec(&#39; echo @?&#39;);
}
$hash = isset($_GET[&#39;hash&#39;]) ? trim($_GET[&#39;hash&#39;]) : &#39;&#39;;

if ($hash != HASH)
{
    header(&#39;HTTP/1.0 403 Forbidden&#39;);
    exit(&#39;Forbidden&#39;);
}

chdir(ROOT_PATH);
shell_exec(sprintf(&amp;quot;echo git auto pull time is %s &amp;gt;&amp;gt; %s&amp;quot;,date(&#39;Y-m-d H:i:s&#39;),LOG_FILE));
shell_exec(sprintf(&amp;quot;git pull origin master &amp;gt;&amp;gt; %s 2&amp;gt;&amp;amp;1 &amp;amp;&amp;quot;,LOG_FILE));
shell_exec(sprintf(&amp;quot;echo git pull status is %s &amp;gt;&amp;gt; %s \n&amp;quot;,getShellStatus(),LOG_FILE));
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;安装方面可以参考这里&lt;a href=&#34;https://laravel-china.org/topics/2192/centos-under-the-use-of-webhook-to-achieve-automatic-deployment-php&#34;&gt;CentOS 下利用 webhook 实现自动部署（PHP）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;相关参考&#34;&gt;相关参考&lt;/h2&gt;

&lt;p&gt;1.如果需要部署项目，可能就需要用到自动部署工具了 php的有两个&lt;a href=&#34;https://deployer.org/&#34;&gt;deploy&lt;/a&gt;和&lt;a href=&#34;http://rocketeer.autopergamene.eu/&#34;&gt;rocketeer&lt;/a&gt;
它们都用到了git&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.ansible.com/&#34;&gt;ansible&lt;/a&gt;不仅仅用于自动部署还用于管理集群&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&#34;https://developer.github.com/webhooks/&#34;&gt;webhooks&lt;/a&gt;github官方说明&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ubuntu 代理设置</title>
      <link>http://i90.xyz/post/vagrant_proxy/</link>
      <pubDate>Fri, 02 Jun 2017 11:39:36 +0800</pubDate>
      
      <guid>http://i90.xyz/post/vagrant_proxy/</guid>
      <description>

&lt;h1 id=&#34;vagrant开发机代理设置&#34;&gt;vagrant开发机代理设置&lt;/h1&gt;

&lt;p&gt;在学习工作中使用&lt;a href=&#34;https://www.vagrantup.com/&#34;&gt;vagrant&lt;/a&gt;作为开发环境已经有很长一段时间了，使用ubuntu
作为开发系统 在使用中发现，即使修改了apt的source.list源文件，在面对一些开发中需要的软件工具的时候，不可
避免的还是会遇到卡顿的问题，于是就查了一下资料，修改apt的proxy代理，来加快速度，最后又把git的也修改了&lt;/p&gt;

&lt;h2 id=&#34;apt-git-npm-composer-等使用遇到的问题&#34;&gt;apt git npm composer 等使用遇到的问题&lt;/h2&gt;

&lt;p&gt;apt git npm composer 由于GFW的存在，对于国内的程序员来说，经常卡住不动，无法使用，即使有镜像源，但由于存在
同步更新的问题，不能及时解决，所以需要进行proxy设置&lt;/p&gt;

&lt;h2 id=&#34;设置proxy&#34;&gt;设置proxy&lt;/h2&gt;

&lt;p&gt;1.git&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	git config --global http.proxy &amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;
	git config --global https.proxy &amp;lt;your proxyip&amp;gt;:&amp;lt;your proxy port&amp;gt;
	
	# socks
	git config --global http.proxy socks5h://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;
	git config --global https.proxy socks5h://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考&lt;a href=&#34;https://gist.github.com/laispace/666dd7b27e9116faece6&#34;&gt;git proxy setting&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.apt&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sudo echo &#39;Acquire::http::Proxy &amp;quot;http://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;&amp;quot;;&#39; &amp;gt;&amp;gt; /etc/apt/apt.conf
 sudo apt update 
 #下面可以体验飞一般的感觉了
 sudo apt install &amp;lt;some packages&amp;gt;
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考&lt;a href=&#34;https://askubuntu.com/questions/257290/configure-proxy-for-apt&#34;&gt;apt proxy setting&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.npm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; npm config set proxy http://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;
 npm config set proxy-https https://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考&lt;a href=&#34;https://stackoverflow.com/questions/25660936/using-npm-behind-corporate-proxy-pac&#34;&gt;npm proxy setting&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.composer&lt;/p&gt;

&lt;p&gt;方法一:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;composer config -g repo.packagist composer https://packagist.phpcomposer.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考&lt;a href=&#34;https://pkg.phpcomposer.com/&#34;&gt;composer中国镜像&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;方法二:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export HTTP_PROXY=http://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;
export HTTPS_PROXY=http://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这种方法临时用一下，每次登录terminal之后需要重新设置，如果不想每次设置，可以保存在&lt;code&gt;~/.profile&lt;/code&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;# proxy setting&amp;quot; &amp;gt;&amp;gt; ~/.profile
echo &amp;quot;export HTTP_PROXY=&#39;http://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;&#39;&amp;quot; &amp;gt;&amp;gt; ~/.profile
echo &amp;quot;export HTTPS_PROXY=&#39;https://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;&#39;&amp;quot; &amp;gt;&amp;gt; ~/.profile
source ~/.profile

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;实际效果&#34;&gt;实际效果&lt;/h2&gt;

&lt;p&gt;git npm apt composer 快了不是一点点 :) !&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于自学能力</title>
      <link>http://i90.xyz/post/about_self_study/</link>
      <pubDate>Thu, 25 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://i90.xyz/post/about_self_study/</guid>
      <description>

&lt;p&gt;原文根据&lt;a href=&#34;https://program-think.blogspot.com/2009/01/2.html&#34;&gt;编程随想&lt;/a&gt; 整理&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;拥有追随自己内心与直觉的勇气, 你的内心与直觉多少已经知道你真正想要成为什么样的人。
Have the courage to follow your heart and intuition. They somehow already know what you truly want to become.
——史蒂夫.乔布斯&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;自学的重要性&#34;&gt;自学的重要性&lt;/h2&gt;

&lt;p&gt;因为大伙儿都明白，IT这行知识的更新速度巨快。有很多新玩意儿在你读书的时候还没有发明出来呢？退一步讲，即使某个新技术
在你上学的时候已经发明出来，你的计算机老师也未必会教你（或许他/她自己也不懂）。再退一步讲，即使你上学时的计算机
老师比较牛，会把当时新出来的某个技术教给你，但是你将来工作中需要用到的新技术未必就当年老师教给你那个&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;　　上面啰嗦了一大堆，无非想说，你工作中终归会需要用到某个新技术是你以前没学过的。所以，自学能力是非常重要滴。
以此相对照的是：国内的大多数开发人员都比较缺乏自学能力（这个也跟国内的教育体制有关）。所以，对于立志成为优秀开发人
员你，需要先搞定自学能力这个东东。&lt;/p&gt;

&lt;h2 id=&#34;自学的主动性&#34;&gt;自学的主动性&lt;/h2&gt;

&lt;p&gt;我把国内的开发人员按照自学的主动性不同，分为如下几类（你顺便想想自己属于哪一类）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;抗拒自学者&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　这类人不愿意自学（部分人是由于懒惰、另一些是由于抵触新事物）。当工作中要用到某项新技术而需要自学时，
他/她就找若干理由推诿。我估计这类人占的比例不多，万一你正好属于这种人，那还是趁早改行，别在这个行业浪费青春了
（因此也别再继续看这个帖子了）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;被动自学者&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这类人平时没事不会想到去自学新东西。只有当上司逼着他去学某某技术，他才勉为其难地去学。
我建议这类人也不用继续看这个系列的帖子了，找个凉快的地方呆着去吧。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需求驱动型自学者&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这类人自学的动机和方向是基于需求驱动。比如因为工作中要用到 XX框架、XX库、XX软件，然后就利用业余时间找资料去看。
如果你属于这类人，就得考虑考虑向第4类人转型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计划型自学者&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这类人自学的动机和方向是基于自己的规划。【定期】看看自己的知识结构有什么缺陷、将来自己想朝什么方向发展、
最近哪个新东西将来会用得上 &amp;hellip;&amp;hellip;然后给自己定一个学习计划。
如果你属于这类人，恭喜你。&lt;/p&gt;

&lt;h2 id=&#34;自学的常用招数&#34;&gt;自学的常用招数&lt;/h2&gt;

&lt;p&gt;现在，咱们来聊聊和自学有关的几个【常用】招数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;搜索引擎&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于使用搜索引擎是互联网时代的必备基本功，搜索引擎的重要性我就不多废话了（千万别跟我说你还不懂得用搜索引擎啊）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;百科类网站&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此处所说的“百科类”例如：中文维基百科、百度百科 &amp;hellip;
百科类网站，顾名思义，就是拿来当百科全书使的。当你听说某个时髦的新术语，但又不甚了解，这时候就可以用上百科类网站了。
各种专业术语一般都可以在百科类网站上查到比较具体的解释。不过百科类网站的功能也就仅限于此，
当你需要深入了解某个技术时，它是远远不够的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;订阅“BBS、Mailing List、Blog”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这3种东东的特点是具有一定的交互性，而且大都支持软件订阅。通过订阅一些专业的、针对某个领域的“BBS、Mailing List、Blog”，
你可以了解该领域的实时动态、了解该领域的热点话题、了解该领域的发展方向。你自己如果碰到疑难杂症，
还可以在上面找人问（运气好的话还能交几个朋友）。
　　为啥我特地强调【订阅】捏？因为使用订阅可以让信息自动跑到你面前，省去了打开浏览器挨个访问网站的麻烦
（因此也节省了时间）。这3种东东的局限性是：难以通过它们【系统性】地掌握某个比较复杂的技术（比如你要学习某
个有一定复杂度的编程语言）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;看书（包括电子书和纸版书）&lt;/p&gt;

&lt;p&gt;当你要系统性地掌握某个比较复杂的技术时，首选方法是：找一本针对性的好书。由于每一个具体的领域，都有N本书可供选择，
这时候如何取舍就非常重要。如果你选的书比较差，不但看起来吃力，甚至会把你带到沟里。
这时候你就得利用搜索引擎或者专门的网站（例如豆瓣、亚马逊）来识别好书与坏书。关于如何鉴别一本书的好坏，
我在帖子《如何选择 IT 技术书籍》里有深入讨论，这里就不再啰嗦了。
　　再来说说电子书和纸版书。首先电子书的资源非常多，大部分国外出版的IT书都可以在Internet上找到免费的电子版。
另外还有电子书还有如下好处：便于携带、能全文搜索、能共享、能备份、还省钱。从目前的发展趋势看，
电子书占据主流地位只是一个时间问题。基于上述理由，所以我很喜欢看电子书（可惜大多数人都没有看电子书的习惯）。
你如果还没有形成看电子书习惯的话，要开始培养了。
　　说完电子版和纸版，再来聊聊中文版和英文版。英文版相对中文版的优势就如同电子版相对纸版的优势一样明显。
国内懂开发又文笔好的IT作家寥寥无几，导致国内出版的IT技术书籍要么翻译国外（翻译过程一般会导致1-2年的滞后、
翻译质量还未必好），要么粗制滥造。所以，你如果不能流利地阅读英文书，赶紧恶补英语吧！
上述4个招数，如能熟练运用，从此自学无忧矣！&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>博客迁移到hugo</title>
      <link>http://i90.xyz/post/welcome/</link>
      <pubDate>Wed, 22 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://i90.xyz/post/welcome/</guid>
      <description>&lt;p&gt;博客开始使用hugo&lt;/p&gt;

&lt;p&gt;首先要说的，blog好久没有更新了。一方面，主要是整体忙这个忙那个，没有顾得上，也有一方面，自己的写作水平
实在有限，当然同大多数人一样，找借口的本领还是很在行的。最终不管怎么，博客是没坚持下去.&lt;/p&gt;

&lt;p&gt;这次把blog迁移到hugo了.记得刚刚学会编程，总是想着弄一个自己的blog，先是自己折腾着，后来换到drupal，
紧接着放到github，以markdown文件形式来写.前几天无意间接触&lt;a href=&#34;https://gohugo.io/&#34;&gt;hugo&lt;/a&gt;,被它这简洁，轻量
的特性和许多个性十足的themes所惊呆了.于是花了几天时间研究，就有了这个blog.&lt;/p&gt;

&lt;p&gt;这个blog最开始参考了&lt;a href=&#34;https://github.com/tanksuzuki/angels-ladder&#34;&gt;angels-ladder&lt;/a&gt;,并在上面的
基础上，去掉了twitter,facebook，加入了新浪微博,调整了一些页面元素,字体等来使整个小站看起来更舒服一些.
总体来说，修补的还说得过去.还有，下面的logo是github找的一个库,用自己的名字转换的,由于原版不支持3个字的名字，所以我
修改了一下，下面放出来&lt;a href=&#34;https://github.com/baykier/letter-avatar&#34;&gt;letter-avatar&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在又到了最后，还是希望能坚持写下去吧,无论是技术上的领悟，还是生活里的开心的不开心的起伏，尽最大的努力记录
下来，等待以后的日子查看 &lt;strong&gt;:)&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>