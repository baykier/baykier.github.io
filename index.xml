<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Baykier的鱼塘</title>
    <link>https://baykier.github.io/</link>
    <description>Recent content on Baykier的鱼塘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 02 Mar 2018 00:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://baykier.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>WebAssembly的发展与对web的影响</title>
      <link>https://baykier.github.io/post/webassembly-with-web/</link>
      <pubDate>Fri, 02 Mar 2018 00:00:00 +0800</pubDate>
      
      <guid>https://baykier.github.io/post/webassembly-with-web/</guid>
      <description> WebAssembly的发展与对web的影响 WebAssembly或称wasm是一个实验性的低级编程语言，应用于浏览器内的客户端。WebAssembly是便携式的抽象语法树，被设计来提供比JavaScript更快速的编译及运行[2]。WebAssembly将让开发者能运用自己熟悉的编程语言（最初以C/C++作为实现目标）编译，再藉虚拟机引擎在浏览器内运行。WebAssembly的开发团队分别来自Mozilla、Google、Microsoft、Apple，代表着四大网络浏览器Firefox、Chrome、Microsoft Edge、Safari[4]。2017年11月，所有以上四个浏览器都开始实验性的支持WebAssembly
简而言之，WebAssembly可以为C和C++编写的源码提供一个编译格式，使其能够运行在浏览器端，并暴露给JavaScript调用，这样一来，对于前端来说，将会引起巨大的变革,比如游戏,视频等等 具体请参考官方文档的介绍WebAssembly的目标
WebAssembly 目前浏览器支持 [x] Chrome [x] Firfox [x] Edge [x] Oprea [x] Android [x] Ios [x] safari [x] wechat
具体参考:
WebAssembly浏览器支持 X5内核升级支持WebAssembly
WebAssembly 编程语言支持 目前完美支持WebAssembly的编程语言如下，相信未来会有更多的语言支持
[x] C [x] C++ [x] Rust [x] Lua
具体参考
WebAssembly语言支持
对Web的影响 目前最主要的编程方式的改变，未来C/C++肯定会在Web前端大放光彩,比如加密解密，视频压缩，裁剪等等，Web平台相应的应用范围得益于WebAssembly也会越来越广，在游戏领域会有更大的作为.
 编程语言C/C++肯定爆发一波 前端开发会越来越重要，原生应用的开发者会面临很大的冲击  相关参考  awesome-WebAssembly http://webassembly.org/  </description>
    </item>
    
    <item>
      <title>vagrant windows 大小写问题解决</title>
      <link>https://baykier.github.io/post/vagrant-win-case-sensetive/</link>
      <pubDate>Thu, 01 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://baykier.github.io/post/vagrant-win-case-sensetive/</guid>
      <description> vagrant windows 大小写问题解决 开发环境使用vagrant，以为这样能很好的解决开发中的坑，没想到还是中了不区分大小写的问题的坑，记录下来，防止踩坑
开发环境: host windwos 10 虚拟机: guest debian8 出现的问题： 工作中使用php开发的cli脚本，需要到线上服务器执行，本地写完了，执行后返回预期的结果，开开心心的到服务器一运行，发现居然没反应(ps 和框架的异常机制也有问题)， 找了半天才发现是文件大小写的问题，由于使用vagrant在linux环境开发，就没有意识到这一点（默哀三秒。。。）然后查找相关资料，才发现使用virtualbox 默认挂载的目录是不区文件分大小写的 在guest中同样也是不区分，最开始的解决思路就是看看php能不能解决这个问题（让php跨平台的支持文件大小写）后来发现php底层是依赖与操作系统的，php本身无法解决，于是重点来了： 如何让windows+virtualbox中的vagrant支持区分文件大小写
vagrant在windows+virtualbox 支持文件区分大小写 要想让vagrant 在windows host中支持文件大小写，需求通过安装插件来支持:nfs
 打开cmd命令行或者git bash:  vagrant plugin install vagrant-winnfsd  等执行完成后进行下一步
 在Vagrantfile添加 挂载参数 type:&amp;ldquo;nfs&amp;rdquo;  config.vm.synced_folder &amp;quot;./project&amp;quot;, &amp;quot;/project&amp;quot;, type:&amp;quot;nfs&amp;quot;   添加private_network支持(插件依赖 https://github.com/winnfsd/vagrant-winnfsd#activate-nfs-for-vagrant):  config.vm.network &amp;quot;private_network&amp;quot;, type: &amp;quot;dhcp&amp;quot;   vagrant reload虚拟机  vagrant reload  ok！ 到这一步，问题算是解决了，让我们愉快的玩耍吧 :) 相关链接  https://github.com/winnfsd/vagrant-winnfsd#activate-nfs-for-vagrant
 https://stackoverflow.com/questions/26483867/how-to-handle-files-in-case-sensitive-way-in-vagrant-on-windows-host
  </description>
    </item>
    
    <item>
      <title>JavaScript跨域访问控制问题</title>
      <link>https://baykier.github.io/post/js_cors/</link>
      <pubDate>Mon, 11 Sep 2017 08:50:38 +0000</pubDate>
      
      <guid>https://baykier.github.io/post/js_cors/</guid>
      <description> JavaScript跨域访问控制问题 问题描述  情景一由于公司的文件上传采用单独的文件服务器管理，把上传文件操作做了统一抽象，形成了一个API接口，不管是前端（包括APP）， 后端，采用文件上传时，均采用一个接口，重要的是文件上传API地址是单独的一台服务器。对于后端和APP端来说，还好 ，但是对于前端（H5）来说，就存在跨域的请求问题
 情景二作为前端开发(H5),本地搭建测试环境，例如http://localhost，链接测试环境的接口http://test.xxxxx.com,这时候，由于 请求的也不是同一个服务器，也会存在跨域问题
  什么是跨域访问 当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求
如何解决跨域请求问题 要解决跨域问题，有两种方式:
 配置服务器，添加允许的跨域访问域名，从而使浏览器正常接收ajax返回的数据  server { listen 80; server_name test.com; location /{ add_header &#39;Access-Control-Allow-Origin&#39; &#39;http://a.com&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;POST&#39;; } }   如果后端使用php，则可以在index.php入口文件简单修改:  // 指定允许其他域名访问 header(&#39;Access-Control-Allow-Origin:http:localhost&#39;); header(&#39;Access-Control-Allow-Credentials:true&#39;); // 响应类型 header(&#39;Access-Control-Allow-Methods:POST&#39;); // 响应头设置 header(&#39;Access-Control-Allow-Headers:x-requested-with,content-type&#39;);  相关阅读  HTTP跨域访问控制 PHP 解决 CORS 跨域问题  </description>
    </item>
    
    <item>
      <title>php扩展模块加载顺序</title>
      <link>https://baykier.github.io/post/php_ext_load_order/</link>
      <pubDate>Wed, 30 Aug 2017 10:31:22 +0000</pubDate>
      
      <guid>https://baykier.github.io/post/php_ext_load_order/</guid>
      <description> php扩展模块的加载顺序 为啥会有这个问题？ 今天在安装php的扩展apm的时候，文档写着必须在json扩展加载之后再加载apm模块,原文如下:
Activate the extension in the php configuration by adding: extension=apm.so Note: APM depends on JSON, so the apm.so extension must be loaded after JSON!  那么php的扩展加载顺序是怎么的? 按照php手册上面的说明，php扩展加载是写在php.ini文件中配置的，而php的配置文件是顺序解析的，这说明除了默认内核扩展，php的其他扩展模块 的加载顺序就是php.ini中的先后顺序，这是针对php.ini中的配置。对于ubuntu来说，php的扩展配置是单独放置在额外的配置目录，每一个扩展加载都是 一个配置文件，类似nginx的站点配置，以ubuntu-16.04-LTS为例：
如果我们要安装php的curl扩展:
sudo apt update &amp;amp;&amp;amp; sudo apt install php7.0-curl  最终会在php的扩展目录安装curl.so（/usr/lib/php/20151012/）,同时会在php的mods_available目录新增配置文件(curl.ini),这时候，php的 curl扩展还没有加载，需要将curl.ini软连接到/etc/php/7.0/fpm/conf.d/，重启php的fpm才会生效
php扩展配置目录 php的fpm扩展加载目录 那么问题来了，如果以这种方式加载php的扩展，扩展的加载顺序如何呢？
答案就是安装配置文件目录的文件自然排序顺序加载的.至于为什么，看了php的扩展加载目录前面的那个数字就明白了。
相关阅读  保证PHP扩展的依赖关系 php的安装与配置  </description>
    </item>
    
    <item>
      <title>nginx ssl 证书配置</title>
      <link>https://baykier.github.io/post/nginx_ssl/</link>
      <pubDate>Tue, 29 Aug 2017 05:23:25 +0000</pubDate>
      
      <guid>https://baykier.github.io/post/nginx_ssl/</guid>
      <description>nginx ssl证书配置 一般在开发环境中，ssl时没有必要设置的，但是因为测试需要用到https环境，所以就记录下来，当学习了。
生成ssl证书 https 需要证书，所需要的证书一般可以自己生成，这时候需要手动添加到浏览器，还有就是去证书网站申请,推荐使用 Let&amp;rsquo;s Encrypt (注:这种证书只能使用3个月的时间，过期需要再次申请) 我们这里仅需要自己手动生成证书就可以了
 生成密钥key,执行下面的命令，输入两次密码就可以了  openssl genrsa -des3 -out dev.key 1024   利用密钥key生成证书crt文件,执行下面的命令，输入证书的参数就可以了  openssl req -new -x509 -key dev.key -out dev.crt -days 3650  证书的参数:
 Country Name 国家名字 (CN 即可) State or Province Name 省或地区(BeiJing) Locality Name 当地地区 (BeiJing) Organization Name 机构名称 (develop Ltd) Organizational Unit Name 组织机构单位 (develop) Common Name 站点host (dev.com) Email Address 邮箱   生成不需要密码的密钥,给nginx配置  openssl rsa -in dev.</description>
    </item>
    
    <item>
      <title>php file_get_contents() 函数代理设置</title>
      <link>https://baykier.github.io/post/php_proxy_file_get_contents/</link>
      <pubDate>Wed, 21 Jun 2017 01:42:02 +0000</pubDate>
      
      <guid>https://baykier.github.io/post/php_proxy_file_get_contents/</guid>
      <description>php file_get_contents() 函数代理设置 遇到的问题 昨天在使用file_get_contents()函数抓取图片内容的时候，出现超时的情况，而且图片无法获取到 据猜测，是网络的问题，有可能被GFW河蟹了，于是登上我的服务器测试一下，发现在服务器可以正常打开。 所以想到了如何给file_get_contents()函数设置代理,记录下来
file_get_contents()代理设置 下面摘自file_get_content()的php官方手册
string file_get_contents ( string $filename [, bool $use_include_path = false [, resource $context [, int $offset = 0 [, int $maxlen ]]]] )  其中，第三个参数context就是一个上下文资源参数，可以使用stream_context_create() 来创建
具体代码如下:
$context = stream_context_create(array( &#39;http&#39; =&amp;gt; array( &#39;proxy&#39; =&amp;gt; &#39;[tcp|udp]&amp;lt;proxy ip&amp;gt;:&amp;lt;proxy port&amp;gt;&#39;, &#39;request_fulluri&#39; =&amp;gt; true, ), )); //下面是简单的测试 $url = &#39;froyo.cc&#39;; $content = file_get_contents($url,false,$context); echo $content;  相关参考 使用strea_context_create()函数的库很多，比如Guzzle
1.php stream
2.理解php的流</description>
    </item>
    
    <item>
      <title>homepage 的自动部署</title>
      <link>https://baykier.github.io/post/auto_deploy/</link>
      <pubDate>Mon, 05 Jun 2017 10:00:36 +0800</pubDate>
      
      <guid>https://baykier.github.io/post/auto_deploy/</guid>
      <description>homepage自动部署 背景 首先交代一下背景，俺的博客是基于hugo的生成静态站点，代码放在github上面 对于hugo 和github不是很了解的同学可以去了解一下。
下面是我写博客的大概流程:
1.在自己的个人电脑上写博客，用hugo生成静态站点测试无误后推送到github
# 新增博客 hugo new post/&amp;lt;some_title&amp;gt;.md # 用编辑器编辑并测试 hugo server -w # 生成静态站点 hugo #推送到github git push origin master  2.在服务器上面拉取更新站点
cd /path/to/site git pull origin master  经过上面的分析可以看出，对于服务器端的每次拉取可以写成一个脚本，利用github的hook机制，这样每次写完博客 测试ok直接推送就行了，省去每次登录服务器，再git pull的操作，这样岂不美哉！
自动部署脚本原理 其实对于这个机智(偷懒)的想法早就有了，直到昨天下午有时间，才完善了一下。网上有很多类似的代码，实现原理 大同小异,都是根据github的hook机制,需要注意的就是安全方面，具体流程如下面:
1.博客更新推送到github
2.github推送webhook到url
3.url里面验证推送的来源(确保安全),执行代码拉取完成更新
编写php脚本(因为php是最好的语言么) 代码可以在这里找到homepage自动部署脚本
&amp;lt;?php /** * homepage 自动更新脚本 */ /** * CSV 软件 Git */ define(&#39;CSV_SOFT&#39;,&#39;git&#39;); /** * HASH for github.com */ define(&#39;HASH&#39;,&#39;59341c1092c47&#39;); define(&#39;ROOT_PATH&#39;,dirname(dirname(__DIR__))); define(&#39;LOG_FILE&#39;,ROOT_PATH .&#39;/git-auto-pull.log&#39;); /** * 获取上次命令的状态 * echo $?</description>
    </item>
    
    <item>
      <title>ubuntu 代理设置</title>
      <link>https://baykier.github.io/post/vagrant_proxy/</link>
      <pubDate>Fri, 02 Jun 2017 11:39:36 +0800</pubDate>
      
      <guid>https://baykier.github.io/post/vagrant_proxy/</guid>
      <description>vagrant开发机代理设置 在学习工作中使用vagrant作为开发环境已经有很长一段时间了，使用ubuntu 作为开发系统 在使用中发现，即使修改了apt的source.list源文件，在面对一些开发中需要的软件工具的时候，不可 避免的还是会遇到卡顿的问题，于是就查了一下资料，修改apt的proxy代理，来加快速度，最后又把git的也修改了
apt git npm composer 等使用遇到的问题 apt git npm composer 由于GFW的存在，对于国内的程序员来说，经常卡住不动，无法使用，即使有镜像源，但由于存在 同步更新的问题，不能及时解决，所以需要进行proxy设置
设置proxy 1.git
	git config --global http.proxy &amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt; git config --global https.proxy &amp;lt;your proxyip&amp;gt;:&amp;lt;your proxy port&amp;gt; # socks git config --global http.proxy socks5h://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt; git config --global https.proxy socks5h://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;  参考git proxy setting
2.apt
 sudo echo &#39;Acquire::http::Proxy &amp;quot;http://&amp;lt;your proxy ip&amp;gt;:&amp;lt;your proxy port&amp;gt;&amp;quot;;&#39; &amp;gt;&amp;gt; /etc/apt/apt.</description>
    </item>
    
    <item>
      <title>关于自学能力</title>
      <link>https://baykier.github.io/post/about_self_study/</link>
      <pubDate>Thu, 25 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://baykier.github.io/post/about_self_study/</guid>
      <description>原文根据编程随想 整理
 拥有追随自己内心与直觉的勇气, 你的内心与直觉多少已经知道你真正想要成为什么样的人。 Have the courage to follow your heart and intuition. They somehow already know what you truly want to become. ——史蒂夫.乔布斯
 自学的重要性 因为大伙儿都明白，IT这行知识的更新速度巨快。有很多新玩意儿在你读书的时候还没有发明出来呢？退一步讲，即使某个新技术 在你上学的时候已经发明出来，你的计算机老师也未必会教你（或许他/她自己也不懂）。再退一步讲，即使你上学时的计算机 老师比较牛，会把当时新出来的某个技术教给你，但是你将来工作中需要用到的新技术未必就当年老师教给你那个&amp;hellip;&amp;hellip;
　上面啰嗦了一大堆，无非想说，你工作中终归会需要用到某个新技术是你以前没学过的。所以，自学能力是非常重要滴。 以此相对照的是：国内的大多数开发人员都比较缺乏自学能力（这个也跟国内的教育体制有关）。所以，对于立志成为优秀开发人 员你，需要先搞定自学能力这个东东。
自学的主动性 我把国内的开发人员按照自学的主动性不同，分为如下几类（你顺便想想自己属于哪一类）：
 抗拒自学者  　这类人不愿意自学（部分人是由于懒惰、另一些是由于抵触新事物）。当工作中要用到某项新技术而需要自学时， 他/她就找若干理由推诿。我估计这类人占的比例不多，万一你正好属于这种人，那还是趁早改行，别在这个行业浪费青春了 （因此也别再继续看这个帖子了）。
 被动自学者  这类人平时没事不会想到去自学新东西。只有当上司逼着他去学某某技术，他才勉为其难地去学。 我建议这类人也不用继续看这个系列的帖子了，找个凉快的地方呆着去吧。
 需求驱动型自学者  这类人自学的动机和方向是基于需求驱动。比如因为工作中要用到 XX框架、XX库、XX软件，然后就利用业余时间找资料去看。 如果你属于这类人，就得考虑考虑向第4类人转型。
 计划型自学者  这类人自学的动机和方向是基于自己的规划。【定期】看看自己的知识结构有什么缺陷、将来自己想朝什么方向发展、 最近哪个新东西将来会用得上 &amp;hellip;&amp;hellip;然后给自己定一个学习计划。 如果你属于这类人，恭喜你。
自学的常用招数 现在，咱们来聊聊和自学有关的几个【常用】招数。
 搜索引擎  由于使用搜索引擎是互联网时代的必备基本功，搜索引擎的重要性我就不多废话了（千万别跟我说你还不懂得用搜索引擎啊）。
 百科类网站  此处所说的“百科类”例如：中文维基百科、百度百科 &amp;hellip; 百科类网站，顾名思义，就是拿来当百科全书使的。当你听说某个时髦的新术语，但又不甚了解，这时候就可以用上百科类网站了。 各种专业术语一般都可以在百科类网站上查到比较具体的解释。不过百科类网站的功能也就仅限于此， 当你需要深入了解某个技术时，它是远远不够的。</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://baykier.github.io/about/</link>
      <pubDate>Tue, 28 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://baykier.github.io/about/</guid>
      <description> 关于我 作为一个码农，不说话上代码:
 $mySelf = new person(); $mySelf-&amp;gt;setName(&amp;quot;Baykier&amp;quot;); $mySelf-&amp;gt;setSex(&amp;quot;男&amp;quot;); $mySelf-&amp;gt;setAge(&amp;quot;保密&amp;quot;); $mySelf-&amp;gt;setAddress(&amp;quot;北京朝阳&amp;quot;); // programing languages $mySelf-&amp;gt;addLanguage(&amp;quot;php&amp;quot;); $mySelf-&amp;gt;addLanguage(&amp;quot;javaScript&amp;quot;); $mySelf-&amp;gt;addLanguage(&amp;quot;html&amp;quot;); $mySelf-&amp;gt;addLanguage(&amp;quot;sql&amp;quot;); // skills $mySelf-&amp;gt;addSkill(&amp;quot;linux&amp;quot;); $mySelf-&amp;gt;addSkill(&amp;quot;mysql&amp;quot;); $mySelf-&amp;gt;addSkill(&amp;quot;docker&amp;quot;);  </description>
    </item>
    
    <item>
      <title>博客迁移到hugo</title>
      <link>https://baykier.github.io/post/welcome/</link>
      <pubDate>Wed, 22 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://baykier.github.io/post/welcome/</guid>
      <description>博客开始使用hugo
首先要说的，blog好久没有更新了。一方面，主要是整体忙这个忙那个，没有顾得上，也有一方面，自己的写作水平 实在有限，当然同大多数人一样，找借口的本领还是很在行的。最终不管怎么，博客是没坚持下去.
这次把blog迁移到hugo了.记得刚刚学会编程，总是想着弄一个自己的blog，先是自己折腾着，后来换到drupal， 紧接着放到github，以markdown文件形式来写.前几天无意间接触hugo,被它这简洁，轻量 的特性和许多个性十足的themes所惊呆了.于是花了几天时间研究，就有了这个blog.
这个blog最开始参考了angels-ladder,并在上面的 基础上，去掉了twitter,facebook，加入了新浪微博,调整了一些页面元素,字体等来使整个小站看起来更舒服一些. 总体来说，修补的还说得过去.还有，下面的logo是github找的一个库,用自己的名字转换的,由于原版不支持3个字的名字，所以我 修改了一下，下面放出来letter-avatar
现在又到了最后，还是希望能坚持写下去吧,无论是技术上的领悟，还是生活里的开心的不开心的起伏，尽最大的努力记录 下来，等待以后的日子查看 :)</description>
    </item>
    
  </channel>
</rss>